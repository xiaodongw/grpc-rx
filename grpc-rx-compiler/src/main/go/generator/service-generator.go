package generator

import (
	"../util"
	"./templates"
	"bytes"
	"fmt"
	"github.com/golang/protobuf/protoc-gen-go/descriptor"
	"path"
	"strconv"
	"strings"
	"text/template"
)

const (
	pluginVersion = "0.5"
)

type StubType int32
type MethodType int32

const (
	AbstractClass   StubType = 0
	AsyncClientImpl StubType = 1
)

const (
	Unary           MethodType = 0
	ServerStreaming MethodType = 1
	ClientStreaming MethodType = 2
	BidiStreaming   MethodType = 3
)

type Message struct {
	Name     string
	JavaName string
	Package  string
}

type Method struct {
	InputType      string
	OutputType     string
	Name           string
	MethodType     MethodType
	GrpcMethodType string
	Id             int
	IdName         string
	FieldName      string
}

type Service struct {
	ProtoFile        string
	ProtoPackageName string
	ProtoServiceName string

	PackageName string
	ServiceName string

	Methods []Method
}

type ServiceGenerator struct {
	*bytes.Buffer

	file     *descriptor.FileDescriptorProto
	service  *descriptor.ServiceDescriptorProto
	indent   string
	messages *map[string]Message
}

// printAtom prints the (atomic, non-annotation) argument to the generated output.
func (g *ServiceGenerator) printAtom(v interface{}) {
	switch v := v.(type) {
	case string:
		g.WriteString(v)
	case *string:
		g.WriteString(*v)
	case bool:
		fmt.Fprint(g, v)
	case *bool:
		fmt.Fprint(g, *v)
	case int:
		fmt.Fprint(g, v)
	case *int32:
		fmt.Fprint(g, *v)
	case *int64:
		fmt.Fprint(g, *v)
	case float64:
		fmt.Fprint(g, v)
	case *float64:
		fmt.Fprint(g, *v)
	default:
		util.Fail(fmt.Sprintf("unknown type in printer: %T", v))
	}
}

// P prints the arguments to the generated output.  It handles strings and int32s, plus
// handling indirections because they may be *string, etc.  Any inputs of type AnnotatedAtoms may emit
// annotations in a .meta file in addition to outputting the atoms themselves (if g.annotateCode
// is true).
func (g *ServiceGenerator) P(str ...interface{}) {
	g.WriteString(g.indent)
	for _, v := range str {
		g.printAtom(v)
	}
	g.WriteByte('\n')
}

// In Indents the output one tab stop.
func (g *ServiceGenerator) In() { g.indent += "\t" }

// Out unindents the output one tab stop.
func (g *ServiceGenerator) Out() {
	if len(g.indent) > 0 {
		g.indent = g.indent[1:]
	}
}

func (g *ServiceGenerator) GetFileName() string {
	// get package name
	pkg := g.file.GetOptions().GetJavaPackage()
	parent := strings.Replace(pkg, ".", "/", -1)
	name := *g.service.Name + "GrpcRx.java"

	return path.Join(parent, name)
}

// Fill the response protocol buffer with the generated output for all the files we're
// supposed to generate.
func (g *ServiceGenerator) Generate() error {
	g.Buffer = new(bytes.Buffer)

	service := g.prepareTemplate()
	tmpl, err := template.New("service").Parse(templates.Service)
	if err != nil {
		return err
	}

	if tmpl.Execute(g.Buffer, service) != nil {
		return nil
	}

	//template.RenderService(service, g.Buffer)

	//g.generateHeader()
	//g.generateImports()
	//g.generateService()
	return nil
}

// Generate the header, including package definition
func (g *ServiceGenerator) generateHeader() {
	g.P("// Code generated by protoc-gen-rxjava. DO NOT EDIT.")
	g.P("// source: ", g.file.Name)
	g.P()
}

// Generate the imports
func (g *ServiceGenerator) generateImports() {
	g.P("import static io.grpc.MethodDescriptor.generateFullMethodName;")
	g.P("import io.grpc.rx.stub.ClientCallsRx;")
	g.P("import io.grpc.rx.stub.ServerCallsRx;")
	g.P()
}

func (g *ServiceGenerator) generateService() {
	packageName := *g.file.Package
	serviceName := *g.file.Name
	serviceClassName := serviceName + "GrpcRx"

	g.P("@javax.annotation.Generated(\n",
		"    value = \"by gRPC proto compiler ", pluginVersion, "\",\n",
		"    comments = \"Source: ", g.file.Name, "\")")
	g.P("public class ", serviceClassName, " {\n\n")
	g.In()
	g.P("private ", serviceClassName, "() {}\n\n")

	g.P("public static final String SERVICE_NAME = ", packageName, ".", serviceName, "\n\n")

	g.generateMethodFields()

	//GrpcWriteDocComment(p, " Creates a new RX stub");

	g.P("public static ", serviceClassName, "Stub newStub(io.grpc.Channel channel) {\n")
	g.In()
	g.P("return new ", serviceClassName, "Stub(channel);\n")
	g.Out()
	g.P("}\n\n")

	//GrpcWriteDocComment(p, " Creates a new RX stub with call options");
	g.P("public static ", serviceClassName, "Stub newStub(io.grpc.Channel channel, io.grpc.CallOptions callOptions) {\n")
	g.In()
	g.P("return new ", serviceClassName, "Stub(channel, callOptions);\n")
	g.Out()
	g.P("}\n\n")

	g.generateStub(AbstractClass)
	g.generateStub(AsyncClientImpl)

	g.generateMethodHandlerClass()
	g.generateGetServiceDescriptorMethod()

	g.Out()
	g.P("}\n")
}

func (g *ServiceGenerator) generateMethodFields() {

}
func (g *ServiceGenerator) generateStub(stubType StubType) {
	serviceName := *g.file.Name
	abstractName := serviceName + "ImplBase"
	stubName := serviceName
	//clientName := serviceName

	isImplBase := false

	switch stubType {
	case AbstractClass:
		isImplBase = true
	case AsyncClientImpl:
		stubName += "Stub"
	default:
		util.Fail("Cannot determine class name for StubType: " /*,stubType*/)
	}

	if isImplBase {
		g.P("public static abstract class ", abstractName, " implements io.grpc.BindableService {\n")
	} else {
		g.P("public static class ", stubName, " extends io.grpc.stub.AbstractStub<", stubName, "> {\n")
	}
	g.In()

	// Constructor and build() method
	if !isImplBase {
		g.P("private ", stubName, "(io.grpc.Channel channel) {\n")
		g.In()
		g.P("super(channel);\n")
		g.Out()
		g.P("}\n\n")

		g.P(
			"private ", stubName, "(io.grpc.Channel channel,\n",
			"    io.grpc.CallOptions callOptions) {\n",
		)
		g.In()
		g.P("super(channel, callOptions);\n")
		g.Out()
		g.P("}\n\n")

		g.P(
			"@java.lang.Override\n",
			"protected $stub_name$ build(io.grpc.Channel channel,\n",
			"    io.grpc.CallOptions callOptions) {\n")
		g.In()
		g.P(
			"return new ", stubName, "(channel, callOptions);\n")
		g.Out()
		g.P("}\n")
	}

	// RPC methods
	for _, method := range g.service.Method {
		inputType := g.javaClassName(method.GetInputType())
		outputType := g.javaClassName(method.GetOutputType())

		lowerMethodName := lowerMethodName(method)
		methodFieldName := methodPropertiesFieldName(method)

		//clientStreaming := method.GetClientStreaming()
		//serverStreaming := method.GetServerStreaming()
		methodType := getMethodType(method)

		// Method signature
		g.P("\n")
		switch methodType {
		case Unary:
			g.P("public io.reactivex.Single<", outputType, "> ", lowerMethodName, "(", inputType, " request)")
		case ServerStreaming:
			g.P("public io.reactivex.Flowable<", outputType, "> ", lowerMethodName, "(", inputType, " request)")
		case ClientStreaming:
			g.P(
				"public io.reactivex.Single<", outputType, "> ", lowerMethodName, "(\n",
				"    io.reactivex.Flowable<", inputType, "> requests)")
		case BidiStreaming:
			g.P(
				"public io.reactivex.Flowable<", outputType, "> ", lowerMethodName, "(\n",
				"    io.reactivex.Flowable<", inputType, "> requests)")
		}

		// Method body.
		g.P(" {\n")
		g.In()
		if isImplBase {
			switch methodType {
			case Unary:
				g.P("return ServerCallsRx.unimplementedUnaryCall($method_field_name$);\n")
			case ServerStreaming:
				g.P("return ServerCallsRx.unimplementedStreamingCall($method_field_name$);\n")
			case ClientStreaming:
				g.P("return ServerCallsRx.unimplementedUnaryCall($method_field_name$);\n")
			case BidiStreaming:
				g.P("return ServerCallsRx.unimplementedStreamingCall($method_field_name$);\n")
			}
		} else {
			var callsMethod string
			var params string
			switch methodType {
			case Unary:
				callsMethod = "ClientCallsRx.unaryCall"
				params = "request"
			case ServerStreaming:
				callsMethod = "ClientCallsRx.serverStreamingCall"
				params = "request"
			case ClientStreaming:
				callsMethod = "ClientCallsRx.clientStreamingCall"
				params = "requests, getCallOptions()"
			case BidiStreaming:
				callsMethod = "ClientCallsRx.bidiStreamingCall"
				params = "requests, getCallOptions()"
			}

			g.P("return ", callsMethod, "(\n",
				"    getChannel().newCall(", methodFieldName, ", getCallOptions()), ", params, ");\n")
		}
		g.Out()
		g.P("}\n")
	}

	if isImplBase {
		g.P("\n")
		g.P("@java.lang.Override public $ServerServiceDefinition$ bindService() {\n")
		//(*vars)["instance"] = "this";
		g.generateBindServiceMethodBody()
		g.P("}\n")
	}

	g.Out()
	g.P("}\n\n")
}

func (g *ServiceGenerator) generateMethodHandlerClass() {
	//// Sort method ids based on client_streaming() so switch tables are compact.
	//vector<const MethodDescriptor*> sorted_methods(service->method_count());
	//for (int i = 0; i < service->method_count(); ++i) {
	//	sorted_methods[i] = service->method(i);
	//}
	//stable_sort(sorted_methods.begin(), sorted_methods.end(),
	//	CompareMethodClientStreaming);

	for index, method := range g.service.Method {
		methodId := strconv.Itoa(index)
		methodIdName := methodIdFieldName(method)
		g.P("private static final int ", methodIdName, " = ", methodId, ";\n")
	}
	g.P("\n")
	serviceName := g.service.GetName() + "ImplBase"
	g.P(
		"private static class MethodHandlers<Req, Resp> implements\n",
		"    io.grpc.rx.stub.ServerCallsRx.UnaryMethod<Req, Resp>,\n",
		"    io.grpc.rx.stub.ServerCallsRx.ServerStreamingMethod<Req, Resp>,\n",
		"    io.grpc.rx.stub.ServerCallsRx.ClientStreamingMethod<Req, Resp>,\n",
		"    io.grpc.rx.stub.ServerCallsRx.BidiStreamingMethod<Req, Resp> {\n",
		"  private final ", serviceName, " serviceImpl;\n",
		"  private final int methodId;\n",
		"\n",
		"  public MethodHandlers(", serviceName, " serviceImpl, int methodId) {\n",
		"    this.serviceImpl = serviceImpl;\n",
		"    this.methodId = methodId;\n",
		"  }\n\n")
	g.In()

	// print unary invoke
	g.generateInvokeMethod(Unary,
		`@java.lang.Override\n
	   @java.lang.SuppressWarnings(\"unchecked\")\n
	   public io.reactivex.Single<Resp> unaryInvoke(Req request) {\n
	     switch (methodId) {\n`,
		`case $method_id_name$:\n
	    return (io.reactivex.Single<Resp>) serviceImpl.$lower_method_name$(($input_type$) request);\n`)

	// print server_stream invoke
	g.generateInvokeMethod(ServerStreaming,
		`@java.lang.Override\n
	  @java.lang.SuppressWarnings(\"unchecked\")\n
	  public io.reactivex.Flowable<Resp> serverStreamingInvoke(Req request) {\n
	    switch (methodId) {\n`,
		`case $method_id_name$:\n
	     return (io.reactivex.Flowable<Resp>) serviceImpl.$lower_method_name$(($input_type$) request);\n`)

	// print client_stream invoke
	g.generateInvokeMethod(ClientStreaming,
		`@java.lang.Override\n
	   @java.lang.SuppressWarnings(\"unchecked\")\n
	   public io.reactivex.Single<Resp> clientStreamingInvoke(io.reactivex.Flowable<Req> requests) {\n
	     switch (methodId) {\n`,
		`case $method_id_name$:\n
	     return (io.reactivex.Single<Resp>) serviceImpl.$lower_method_name$((io.reactivex.Flowable<$input_type$>) requests);\n`)

	// print bidi_stream invoke
	g.generateInvokeMethod(BidiStreaming,
		`@java.lang.Override\n
	  @java.lang.SuppressWarnings(\"unchecked\")\n
	  public io.reactivex.Flowable<Resp> bidiStreamingInvoke(io.reactivex.Flowable<Req> requests) {\n
	    switch (methodId) {\n`,
		`case $method_id_name$:\n
	    return (io.reactivex.Flowable<Resp>) serviceImpl.$lower_method_name$((io.reactivex.Flowable<$input_type$>) requests);\n`)

	g.Out()
	g.P("}\n\n")
}

func (g *ServiceGenerator) generateGetServiceDescriptorMethod() {
	//serviceName := g.service.GetName()

	protoDescriptorSupplier := g.service.GetName() + "DescriptorSupplier"
	protoClassName := g.javaClassName(g.service.GetName())

	g.P("private static final class ", protoDescriptorSupplier, " implements io.grpc.protobuf.ProtoFileDescriptorSupplier {\n")
	g.In()
	g.P("@java.lang.Override")
	g.P("public com.google.protobuf.Descriptors.FileDescriptor getFileDescriptor() {\n")
	g.In()
	g.P("return ", protoClassName, ".getDescriptor();\n")
	g.Out()
	g.P("}\n")
	g.Out()
	g.P("}\n\n")

	g.P(
		"private static volatile io.grpc.ServiceDescriptor serviceDescriptor;\n\n")

	g.P(
		"public static io.grpc.ServiceDescriptor getServiceDescriptor() {\n")
	g.In()
	g.P(
		"io.grpc.ServiceDescriptor result = serviceDescriptor;\n")
	g.P("if (result == null) {\n")
	g.In()
	g.P(
		"synchronized ($service_class_name$.class) {\n")
	g.In()
	g.P("result = serviceDescriptor;\n")
	g.P("if (result == null) {\n")
	g.In()

	g.P(
		"serviceDescriptor = result = io.grpc.ServiceDescriptor.newBuilder(SERVICE_NAME)")
	g.In()
	g.In()

	g.P("\n.setSchemaDescriptor(new $proto_descriptor_supplier$())")

	for _, method := range g.service.Method {
		methodFieldName := methodPropertiesFieldName(method)
		g.P("\n.addMethod(", methodFieldName, ")")
	}
	g.P("\n.build();\n")
	g.Out()
	g.Out()

	g.Out()
	g.P("}\n")
	g.Out()
	g.P("}\n")
	g.Out()
	g.P("}\n")
	g.P("return result;\n")
	g.Out()
	g.P("}\n")
}

func (g *ServiceGenerator) generateInvokeMethod(methodTypeFilter MethodType, methodTemplate string, caseTemplate string) {
	g.P(methodTemplate)
	g.In()
	g.In()

	for _, method := range g.service.Method {
		methodType := getMethodType(method)
		if methodType != methodTypeFilter {
			continue
		}

		// todo how to pass them to template
		//methodIdName := methodIdFieldName(method)
		//lowerMethodName := lowerMethodName(method)
		//inputType := messageFullJavaName(method.GetInputType())
		//outputType := messageFullJavaName(method.GetOutputType())
		g.P(caseTemplate)
	}

	g.P("default:\n",
		"  throw new AssertionError();\n")

	g.Out()
	g.Out()
	g.P("  }\n",
		"}\n\n")
}

func (g *ServiceGenerator) prepareTemplate() *Service {
	methods := make([]Method, len(g.service.Method))
	for i, method := range g.service.Method {
		methodType := getMethodType(method)
		methods[i] = Method{
			Name:           method.GetName(),
			InputType:      g.javaClassName(method.GetInputType()),
			OutputType:     g.javaClassName(method.GetOutputType()),
			MethodType:     methodType,
			GrpcMethodType: getGrpcMethodType(methodType),
			Id:             i,
			IdName:         methodIdFieldName(method),
			FieldName:      methodPropertiesFieldName(method),
		}
	}

	service := Service{
		PackageName:      g.file.GetOptions().GetJavaPackage(),
		ServiceName:      g.service.GetName(),
		ProtoFile:        g.file.GetName(),
		ProtoPackageName: g.file.GetPackage(),
		ProtoServiceName: g.file.GetPackage() + "." + g.service.GetName(),
		Methods:          methods,
	}

	return &service
}

func (m *Method) FullInputType() string {
	switch m.MethodType {
	case Unary:
		fallthrough
	case ServerStreaming:
		return m.InputType
	case ClientStreaming:
		fallthrough
	case BidiStreaming:
		return "io.reactivex.Flowable<" + m.InputType + ">"
	default:
		return "UNKNOWN"
	}
}

func (m *Method) FullOutputType() string {
	switch m.MethodType {
	case Unary:
		fallthrough
	case ClientStreaming:
		return "io.reactivex.Single<" + m.OutputType + ">"
	case ServerStreaming:
		fallthrough
	case BidiStreaming:
		return "io.reactivex.Flowable<" + m.OutputType + ">"
	default:
		return "UNKNOWN"
	}
}

func (m *Method) UnimplementedCall() string {
	switch m.MethodType {
	case Unary:
		fallthrough
	case ClientStreaming:
		return "unimplementedUnaryCall"
	case ServerStreaming:
		fallthrough
	case BidiStreaming:
		return "unimplementedStreamingCall"
	default:
		return "UNKNOWN"
	}
}

func (m *Method) Call() string {
	switch m.MethodType {
	case Unary:
		return "unaryCall"
	case ClientStreaming:
		return "clientStreamingCall"
	case ServerStreaming:
		return "serverStreamingCall"
	case BidiStreaming:
		return "bidiStreamingCall"
	default:
		return "UNKNOWN"
	}
}

func (m *Method) CallParams() string {
	switch m.MethodType {
	case Unary:
		fallthrough
	case ServerStreaming:
		return "request"
	case ClientStreaming:
		fallthrough
	case BidiStreaming:
		return "request, getCallOptions()"
	default:
		return "UNKNOWN"
	}
}

func getGrpcMethodType(methodType MethodType) string {
	switch methodType {
	case Unary:
		return "UNARY"
	case ServerStreaming:
		return "SERVER_STREAMING"
	case ClientStreaming:
		return "CLIENT_STREAMING"
	case BidiStreaming:
		return "BIDI_STREAMING"
	default:
		return "UNKNOWN"
	}
}

func (g *ServiceGenerator) generateBindServiceMethodBody() {
	//serviceName := g.service.GetName()

	g.In()
	g.P(
		"return ",
		"io.grpc.ServerServiceDefinition.builder(getServiceDescriptor())\n")
	g.In()
	g.In()

	for _, method := range g.service.Method {
		//lowerMethodName := lowerMethodName(method)
		//methodFieldName := methodPropertiesFieldName(method)
		//inputType := messageFullJavaName(method.GetInputType())
		//outputType := messageFullJavaName(method.GetOutputType())
		//methodIdName := methodIdFieldName(method)
		clientStreaming := method.GetClientStreaming()
		serverStreaming := method.GetServerStreaming()
		var callsMethod string
		if clientStreaming {
			if serverStreaming {
				callsMethod = "ServerCallsRx.bidiStreamingCall"
			} else {
				callsMethod = "ServerCallsRx.clientStreamingCall"
			}
		} else {
			if serverStreaming {
				callsMethod = "ServerCallsRx.serverStreamingCall"
			} else {
				callsMethod = "ServerCallsRx.unaryCall"
			}
		}
		// ref callsMethod to suppress compile error
		_ = callsMethod

		g.P(".addMethod(\n")
		g.In()
		g.P(
			"$method_field_name$,\n",
			"$calls_method$(\n")
		g.In()
		g.P(
			"new MethodHandlers<\n",
			"  $input_type$,\n",
			"  $output_type$>(\n",
			"    this, $method_id_name$)))\n")
		g.Out()
		g.Out()
	}
	g.P(".build();\n")
	g.Out()
	g.Out()
	g.Out()
}

func getMethodType(method *descriptor.MethodDescriptorProto) MethodType {
	clientStreaming := method.GetClientStreaming()
	serverStreaming := method.GetServerStreaming()
	if clientStreaming {
		if serverStreaming {
			return BidiStreaming
		} else {
			return ClientStreaming
		}
	} else {
		if serverStreaming {
			return ServerStreaming
		} else {
			return Unary
		}
	}
}

// Adjust a method name prefix identifier to follow the JavaBean spec:
//   - decapitalize the first letter
//   - remove embedded underscores & capitalize the following letter
func mixedLower(word string) string {
	// todo implement it
	//string w;
	//w += tolower(word[0]);
	//bool after_underscore = false;
	//for (size_t i = 1; i < word.length(); ++i) {
	//if (word[i] == '_') {
	//after_underscore = true;
	//} else {
	//w += after_underscore ? toupper(word[i]) : word[i];
	//after_underscore = false;
	//}
	//}
	//return w;
	return word
}

// Converts to the identifier to the ALL_UPPER_CASE format.
//   - An underscore is inserted where a lower case letter is followed by an
//     upper case letter.
//   - All letters are converted to upper case
func toAllUpperCase(word string) string {
	// todo add underscore
	return strings.ToUpper(word)
}

func lowerMethodName(method *descriptor.MethodDescriptorProto) string {
	return mixedLower(method.GetName())
}

func methodPropertiesFieldName(method *descriptor.MethodDescriptorProto) string {
	return "METHOD_" + toAllUpperCase(method.GetName())
}

func methodIdFieldName(method *descriptor.MethodDescriptorProto) string {
	return "METHODID_" + toAllUpperCase(method.GetName())
}

func (g *ServiceGenerator) javaClassName(messageType string) string {
	return (*g.messages)[strings.Trim(messageType, ".")].JavaName
}
